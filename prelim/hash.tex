% !TEX root = ../main-ring-signature.tex

We recall the definition of a hash function plus a weaker notion where the adversary needs to find a second preimage (see \cite{FSE:RogShr04}). We consider a functions $h:\mathcal{K}\times\mathcal{M}\to\mathcal{Y}$ and an algorithm $\KGen$ which on input a group key randomly samples an element from $\mathcal{K}$.

\begin{definition}[Collision Resistance]\label{def:hash1}
 We say that $h$ is a hash-function family with collision resistance if for all PPT adversary $\advA$
$$
\adv_h^{\mathsf{Col}}(\advA) := \Pr[k\gets\KGen(1^\lambda), (x,x')\gets \advA(k):x\neq x'\text{ and }h_k(x)=h_k(x')]
$$ 
is negligible in $\lambda$.
\label{def:collision-resistance}
\end{definition}

We use a weaker variant of collision resistance for our hash function based on the PPA assumption.

\begin{definition}[Second-Preimage Resistance]\label{def:hash2}
 We say that $h$ is a hash-function family with always second-preimage resistance if for all PPT adversary $\advA$
$$
\adv_h^{\mathsf{Sec}}(\advA) := \Pr\left[\begin{array}{c}
k\gets\KGen(gk), x\gets\mathcal{M}, x'\gets A(k,x):\\
 x\neq x'\text{ and }h_k(x)=h_k(x')
 \end{array}\right]
$$ 
is negligible in $\lambda$.
\end{definition}
%We also define an adaptive variant of second-preimage resistance  which consider attacks were the adversary computes its own key $k'$ such that $g_{k'}(x') = g_{k}(x)$. We require that $k\sim k'$, where $\sim\subset \mathcal{K}\times\mathcal{K}$ is an equivalence relation (in our ring signature we will consider $k\sim k\iff h(k)=h(k')$, for another collision resistance hash function $h$)
%
%\begin{definition}[Key-Flexible Adaptive Second-Preimage Resistance]\label{def:KaSec}
% A hash-function family $h$ with distributed key generation is adaptive second-preimage resistant if for all PPT adversary $\advA$
%$$
%\adv_g^{\mathsf{KaSec}}(\advA) := \Pr\left[\begin{array}{c}
%k_0\gets\KGen_{\mathsf{global}}(gk), x\gets\mathcal{M},(k',x')\gets \advA^{\mathsf{KeyGen},\mathsf{Corrupt}}(k_0):\\
%k\sim k', x_{I\setminus Q} \neq x_{I\setminus Q}\text{ and }g_k(x)=g_k(x')
%\end{array}\right]
%$$ 
%is negligible in $\lambda$.  The $i$-th call to the oracle $\mathsf{KeyGen}(\mathsf{aux}_i)$ stores $i$ on $I$, if $i\notin I$, and returns $k_i:=\KGen(gk,k_0,\mathsf{aux}_i;r_i)$, for a uniform $r_i\in\bits^{\mathsf{poly}(\lambda)}$. The oracle $\mathsf{Corrupt}(i)$ returns the random coins used to generate $k_i$, if $i\in I$, and stores $i$ in $Q$. For an index set $S  = \{s_1,\ldots,s_n\}$, condition $x_{S} \neq x'_{S}$ means that $(x_{s_1},\ldots, x_{s_n})\neq (x'_{s_1},\ldots,x'_{s_n})$. 
%\end{definition}